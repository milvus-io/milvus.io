{
  "title": "Outil de dimensionnement Milvus",
  "content": "Un outil pour estimer les besoins en ressources et générer une configuration pour votre déploiement Milvus.",
  "tooltip": "<0>Note</0> : la configuration est notre meilleure estimation basée sur l'expérience, mais nous vous suggérons de tester avec vos données et votre modèle de trafic avant de lancer en production.",
  "form": {
    "num": "Nombre de vecteurs",
    "dim": "Dimension du vecteur",
    "withScalar": "Avec champs scalaires",
    "averageLength": "Taille moyenne des données par ligne",
    "offloading": "Déchargement des champs sur le disque",
    "mmp": "Milvus utilise <0>Mmap</0> pour permettre un accès direct à la mémoire des gros fichiers sur le disque sans lire les fichiers entiers en mémoire.",
    "indexType": "Type d'index",
    "indexTypeTip": "Comment choisir l'index vectoriel ?",
    "indexParam": "Paramètres d'index",
    "indexParamTip": "Comment définir les bons paramètres d'index ? <0>en savoir plus</0>.",
    "withRawData": "with_raw_data",
    "m": "M (Degré maximum du nœud)",
    "nlist": "nlist",
    "maxDegree": "max_degree",
    "segmentSize": "Taille du segment",
    "dependencyComp": "Composant de dépendance",
    "mode": "Mode",
    "modeTip": "À mesure que la taille de vos données augmente, vous pouvez migrer les données du mode autonome vers le mode cluster. <0>Voir plus</0>.",
    "modeDisableTip": "Pour les grandes tailles de données, il est recommandé d'utiliser le déploiement en mode cluster pour obtenir de meilleures performances et évolutivité.",
    "pulsar": "Pulsar",
    "kafka": "Kafka",
    "standalone": "Autonome",
    "standaloneDesc": "Adapté pour les petites à moyennes échelles.",
    "cluster": "Distribué",
    "clusterDesc": "Adapté pour les grandes échelles.",
    "segmentTooltip": "datacoord.segment.maxSize est un paramètre de configuration de stockage important dans Milvus. Il définit la taille d'un segment unique, qui est l'unité de stockage physique dans Milvus. L'augmentation de cette valeur peut améliorer les performances des requêtes, mais elle consomme également plus de ressources. <0>En savoir plus.</0>"
  },
  "overview": {
    "title": "Besoins en ressources",
    "explore": "Explorer le coût du service géré",
    "overview": "Calcul de la taille des données",
    "raw": "Taille des données brutes : ",
    "rawTooltip": "La taille des données d'origine qui est déterminée par le nombre de vecteurs, la dimension du vecteur et la taille des données du champ scalaire.",
    "memory": "Mémoire de chargement : ",
    "memoryTooltip": "Consommation de mémoire pour les nœuds de requête qui est déterminée par la taille des données brutes, le type d'index et les paramètres pour les nœuds de requête."
  },
  "setup": {
    "title": "Configuration des besoins en ressources",
    "cloud": "Explorer le coût du service géré",
    "outOfRange": "Vous avez une grande quantité de données. Veuillez <0>nous contacter</0> pour explorer les meilleures pratiques de déploiement.",
    "milvus": {
      "title": "Milvus",
      "proxy": "Proxy",
      "mixCoord": "Mix Coord",
      "dataNode": "Nœud de données",
      "indexNode": "Nœud d'index",
      "queryNode": "Nœud de requête",
      "diskSize": "<0>Disque local</0> : <1>{{size}}</1>",
      "proxyTip": "Le proxy est la couche d'accès du système et le point de terminaison pour les utilisateurs. Astuce : Allouez plus de ressources pour gérer une charge de travail QPS plus élevée.",
      "mixCoordTip": "Mix coord est responsable de la planification des tâches en arrière-plan du cluster, du maintien de la topologie des métadonnées, de la gestion des DDL, DCL et de l'allocation des TSO.",
      "queryNodeTip": "Le nœud de requête est responsable de la requête et de la recherche de données. Astuce : Allouez plus de ressources pour gérer une charge de travail intensive en lecture.",
      "dataNodeTip": "Le nœud de données récupère les données de journal incrémentielles en s'abonnant au courtier de journal, traite les demandes de mutation et emballe les données de journal dans des instantanés de journal et les stocke dans le stockage d'objets. Astuce : Allouez plus de ressources pour gérer une charge de travail intensive en écriture.",
      "indexNodeTip": "Le nœud d'index est responsable de la construction des index. La quantité de ressources peut affecter la vitesse de construction de l'index. Vous pouvez augmenter ou diminuer cette ressource en fonction des besoins réels.",
      "standaloneNode": "Nœud autonome",
      "streamNode": "Nœud de flux",
      "streamNodeTip": "Le StreamingNode est responsable de la gestion de toutes les tâches de diffusion en continu. Le nombre de ressources affecte directement le débit et la latence de Milvus pour toutes les opérations de diffusion en continu, y compris la recherche de données croissantes, l'écriture de données, la convention de données de wal à binlog (données de diffusion en continu vers des données historiques)."
    },
    "dependency": {
      "title": "Dépendance",
      "etcd": "ETCD",
      "minio": "Minio",
      "pulsar": "Pulsar",
      "kafka": "Kafka",
      "bookie": "Bookie",
      "broker": "Broker",
      "proxy": "Proxy",
      "zookeeper": "Zookeeper",
      "etcdTip": "ETCD est utilisé pour stocker les métadonnées. Veuillez spécifier une classe de stockage à haute performance de disque pour assurer des performances optimales.",
      "apacheTip": "Veuillez spécifier une classe de stockage à haute performance de disque pour Bookie.Journal et Zookeeper pour assurer des performances optimales.",
      "kafkaTip": "Veuillez spécifier une classe de stockage à haute performance de disque pour Zookeeper pour assurer des performances optimales."
    },
    "basic": {
      "cpuAndMemory": "CPU et mémoire : <0>{{cpu}} {{memory}}</0>",
      "storageWithValue": "Stockage : <0>{{size}}</0>",
      "diskWithValue": "Disque local : <0>{{disk}}</0>",
      "cpu": "CPU",
      "memory": "Mémoire",
      "disk": "Disque local",
      "storage": "Stockage",
      "podNum": "Nombre de pods",
      "pvc": "Pvc par pod : <0>{{pvc}}</0>",
      "pvcLabel": "Pvc par pod",
      "journal": "Journal",
      "ledger": "Ledgers",
      "config": "{{cpu}} Core {{memory}} GB",
      "core": "{{cpu}} Core",
      "simpleCore": "{{cpu}} C",
      "gb": "{{memory}} GB",
      "byte": "Bytes"
    }
  },
  "install": {
    "title": "Installer Milvus",
    "helm": "Helm Chart",
    "operator": "Opérateur Milvus",
    "docker": "Docker Compose",
    "adv": "Trop de ressources consommées ? Essayez Zilliz Cloud (Milvus géré) pour économiser des ressources et réduire les coûts de déploiement et d'exploitation. Découvrez plus de détails avec le calculateur Zilliz Cloud. <0>Aller au calculateur Zilliz Cloud</0>.",
    "adv2": "Configurer un cluster Milvus pour des tests de performance ou des benchmarks ? Reportez-vous à <0>VDB Bench</0> pour des instructions détaillées.",
    "tip1": "Comment exécuter Milvus avec Docker Compose ?",
    "tip2": "Comment exécuter Milvus avec Helm Chart ?",
    "tip3": "Comment exécuter Milvus avec l'opérateur Milvus ?"
  },
  "woodpeckerTip": "Le <0>pivert</0> est responsable de la gestion de toutes les tâches de diffusion en continu. Le nombre de ressources affecte directement le débit et la latence de Milvus pour toutes les opérations de diffusion en continu, y compris la recherche de données croissantes, l'écriture de données, la convention de données de wal à binlog (données de diffusion en continu vers des données historiques)."
}
